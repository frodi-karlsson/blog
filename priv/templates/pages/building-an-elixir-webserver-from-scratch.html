<% layout.html %>
  <slot:title>How I Built This Blog from Scratch in Elixir</slot:title>
  <slot:description>A deep dive into the custom-built Elixir webserver powering this very page.</slot:description>
  <slot:canonical>https://blog.frodikarlsson.com/building-an-elixir-webserver-from-scratch</slot:canonical>
  <slot:og_type>article</slot:og_type>
  <slot:body>
    <% blog_post.html %>
      <slot:category>Elixir</slot:category>
      <slot:date>Feb 25, 2026</slot:date>
      <slot:title>How I Built This Blog from Scratch in Elixir</slot:title>
      <slot:content>
        <p>This blog isn't running on WordPress, Phoenix, or even a static site generator. It's running on a custom webserver I wrote in Elixir while stuck in bed with a cold. I didn't want to pull in a massive framework just to serve some HTML, so I built exactly what I needed.</p>

        <p>I'm primarily a Node developer, but I've been wanting to explore Elixir and the BEAM. This project was the perfect excuse to dive in and see how it handles the basics of the web.</p>

        <h2>Performance on a Budget</h2>
        <p>The entire application is hosted on the cheapest DigitalOcean droplet available for just <strong>$4 a month</strong>. Despite the minimal resources, it achieves near-perfect Lighthouse scores. The combination of Elixir's efficiency and a lack of client-side bloat makes it fly.</p>

        <figure>
          <img src="/static/img/web-vitals.png" alt="Web Vitals: Performance 98, Accessibility 100, Best Practices 96, SEO 100" />
          <figcaption>Lighthouse scores for this very page.</figcaption>
        </figure>

        <h2>Routing Requests</h2>
        <p>I used <a href="https://hexdocs.pm/plug/Plug.Router.html" target="_blank" rel="noopener noreferrer">Plug.Router</a> to handle the routing. It's a simple, declarative way to map paths to functions. Here's how the main router is structured:</p>

        <pre><code class="language-elixir">defmodule Webserver.Router do
  use Plug.Router
  # ... imports and aliases ...

  plug(Plug.RequestId)
  plug(Plug.Logger)
  plug(Plug.Static, at: "/static", from: {:webserver, "priv/static"})

  plug(:match)
  plug(:dispatch)

  get "/health" do: json(conn, 200, %{status: "ok"})
  get "/live-reload", to: Webserver.LiveReload
  forward "/admin", to: AdminRouter
  forward "/", to: Webserver.Server
end</code></pre>

        <h2>The Core Server Loop</h2>
        <p>The main logic for serving pages lives in <code>Webserver.Server</code>. It takes the request path, looks it up in the cache, and returns the parsed HTML. If the page doesn't exist, it handles the 404 gracefully.</p>

        <pre><code class="language-elixir">def call(conn, _opts) do
  path = request_path(conn)
  result = try_get_page(path)

  case result do
    {:ok, parsed} ->
      conn
      |> put_resp_content_type("text/html")
      |> send_resp(200, parsed)
    {:error, :not_found} ->
      # Render custom 404 page...
  end
end</code></pre>

        <h2>Caching with ETS</h2>
        <p>To keep things fast, I use <a href="https://hexdocs.pm/elixir/main/ets.html" target="_blank" rel="noopener noreferrer">ETS</a> (Erlang Term Storage) for caching parsed templates. Multiple processes can read from the cache simultaneously without any locking, which is essential for high concurrency.</p>

        <pre><code class="language-elixir">def get_page(server, path) do
  table = table_for(server)

  case :ets.lookup(table, {:page, path}) do
    [{_, %PageEntry{} = entry}] ->
      handle_maybe_stale(table, server, path, entry)

    [] ->
      GenServer.call(server, {:fetch_and_cache, path})
  end
end</code></pre>

        <h2>A Custom Templating Language</h2>
        <p>I wanted a component-like experience without a heavy build step. I wrote a small templating system that supports partials and named slots using recursive regex. It allows me to define layouts and reuse components easily.</p>

        <pre><code class="language-html">&lt;% layout.html %&gt;
  &lt;slot:title&gt;My Page&lt;/slot:title&gt;
  &lt;slot:body&gt;
    &lt;% header.html %/&gt;
    &lt;p&gt;Content goes here.&lt;/p&gt;
  &lt;/slot:body&gt;
&lt;%/ layout.html %&gt;</code></pre>

        <h2>Live Reload</h2>
        <p>For a smooth development experience, I implemented live reloading. The server watches the filesystem using <a href="https://github.com/synrc/fs" target="_blank" rel="noopener noreferrer">fs</a>. The browser keeps an SSE connection open, and when a change is detected, the server sends a signal to reload the page or swap CSS in place.</p>

        <h2>Hosting and Deployment</h2>
        <p>Deployment is fully automated with GitHub Actions and Docker. When I push to <code>main</code>, an image is built and pushed to GHCR. On the droplet, <a href="https://containrrr.dev/watchtower/" target="_blank" rel="noopener noreferrer">Watchtower</a> detects the new image and restarts the container within 30 seconds. No manual intervention required.</p>

        <h2>Elixir vs Node</h2>
        <p>Most of my professional work is in TypeScript and Node. They are great tools, but where they often struggle is concurrency. Node's single-threaded event loop requires workarounds for heavy lifting. In Elixir, concurrency is a first-class citizen.</p>

        <p>The Erlang VM (BEAM) is perfect for this kind of work. It doesn't have <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" target="_blank" rel="noopener noreferrer">colored functions</a>. You don't think about async versus sync because the <a href="https://www.erlang.org/blog/a-brief-beam-primer/" target="_blank" rel="noopener noreferrer">BEAM</a> handles scheduling for you. Every request gets its own process, making it incredibly resilient and efficient. If a process crashes, the supervisor restarts it, and nothing else is affected.</p>

        <p>Building this from scratch over the last few days has been a great way to learn Elixir. It's a powerful, elegant language that makes building resilient systems feel natural. It's definitely a tool I'll be reaching for again.</p>

        <p>You can even <a href="https://github.com/frodi-karlsson/blog/blob/main/priv/templates/pages/building-an-elixir-webserver-from-scratch.html" target="_blank" rel="noopener noreferrer">view the source for this very page on GitHub</a> to see how the templating works in practice.</p>
      </slot:content>
    <%/ blog_post.html %>
  </slot:body>
<%/ layout.html %>
